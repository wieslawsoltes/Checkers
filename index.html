<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Checkers: CPU vs CPU / Human vs CPU</title>
  <style>
    body { 
      text-align: center; 
      font-family: sans-serif; 
      margin: 0;
      padding: 0;
    }
    #boardContainer {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    canvas { 
      border: 2px solid #000; 
      cursor: pointer; 
      max-width: 90vw; 
      height: auto;
    }
    #controls { margin-top: 10px; }
    #controls button { margin: 0 5px; }
    #gameHistory div { 
      display: inline-block; 
      margin: 5px; 
      border: 1px solid #000; 
      padding: 5px; 
    }
    #gameHistory img { display: block; margin: 5px auto; }
    #modeSelection { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Checkers Game</h1>
  <div id="modeSelection">
    <label>Select Game Mode: </label>
    <select id="gameModeSelect">
      <option value="cpu">CPU vs CPU</option>
      <option value="human">Human vs CPU</option>
    </select>
    <button id="startGameBtn">Start Game</button>
  </div>
  
  <div id="boardContainer">
    <canvas id="checkers" width="480" height="480" style="display:none;"></canvas>
  </div>
  
  <div id="controls" style="display:none;">
    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
    <!-- New Suggest Move button for human mode -->
    <button id="suggestMoveBtn">Show Suggestion</button>
    <button id="backBtn">Back to Game Selection</button>
  </div>
  
  <div id="winnerDisplay" style="margin-top:10px; font-size:18px; font-weight:bold;"></div>
  <h2>Game History</h2>
  <div id="gameHistory"></div>

  <script>
    // Global Variables
    let board;
    const canvas = document.getElementById('checkers');
    const ctx = canvas.getContext('2d');
    const squareSize = 60; // 8 squares => 480px canvas

    let currentPlayer = 1;  // Player 1: CPU1 (or Human) | Player -1: CPU2
    const maxDepth = 4;   // Depth for minimax search

    // Counters for stagnant play.
    let moveCount = 0;
    let noCaptureCount = 0;
    const MAX_MOVES = 100;          
    const MAX_NO_CAPTURE_MOVES = 40;  

    // Game control flags and mode.
    let paused = false;
    let gameActive = false;  // True when a game is running.
    let gameMode = "cpu";    // "cpu" or "human"
    let selectedPiece = null; // For human move selection

    // Variables for suggested move (Human vs CPU)
    let showSuggestion = false;
    let suggestedMove = null;

    // ----------------- Board Setup & Rendering -----------------
    // Create initial board state.
    function initializeBoard() {
      let b = [];
      for(let r = 0; r < 8; r++){
        b[r] = [];
        for(let c = 0; c < 8; c++){
          b[r][c] = 0;
        }
      }
      // CPU2 pieces on rows 0,1,2 (black pieces, represented as -1)
      for(let r = 0; r < 3; r++){
        for(let c = 0; c < 8; c++){
          if((r + c) % 2 === 1) {
            b[r][c] = -1;
          }
        }
      }
      // CPU1 pieces on rows 5,6,7 (red pieces, represented as 1)
      for(let r = 5; r < 8; r++){
        for(let c = 0; c < 8; c++){
          if((r + c) % 2 === 1) {
            b[r][c] = 1;
          }
        }
      }
      return b;
    }

    // Draw the board and pieces.
    function drawBoard() {
      // Draw squares.
      for(let r = 0; r < 8; r++){
        for(let c = 0; c < 8; c++){
          ctx.fillStyle = ((r+c) % 2 === 0) ? '#EEE' : '#555';
          ctx.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);
        }
      }
      // Draw pieces.
      for(let r = 0; r < 8; r++){
        for(let c = 0; c < 8; c++){
          if(board[r][c] !== 0) {
            if(Math.abs(board[r][c]) === 1) {
              ctx.fillStyle = (board[r][c] === 1) ? 'red' : 'black';
            } else {
              // Kings: use a different shade and add gold outline.
              ctx.fillStyle = (board[r][c] === 2) ? 'pink' : 'gray';
            }
            ctx.beginPath();
            ctx.arc(c * squareSize + squareSize/2, r * squareSize + squareSize/2, squareSize/2 - 5, 0, Math.PI * 2);
            ctx.fill();
            if(Math.abs(board[r][c]) === 2) {
              ctx.strokeStyle = 'gold';
              ctx.lineWidth = 3;
              ctx.stroke();
            }
          }
        }
      }
      // If a piece is selected (human mode), highlight it.
      if(selectedPiece) {
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 3;
        ctx.strokeRect(selectedPiece.c * squareSize, selectedPiece.r * squareSize, squareSize, squareSize);
      }
      // If suggestion is enabled and it's the human's turn, draw the suggestion.
      if(gameMode === "human" && currentPlayer === 1 && showSuggestion && suggestedMove) {
        ctx.strokeStyle = "lime";
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        // Highlight source square.
        ctx.strokeRect(suggestedMove.from.c * squareSize, suggestedMove.from.r * squareSize, squareSize, squareSize);
        // Highlight destination square.
        ctx.strokeRect(suggestedMove.to.c * squareSize, suggestedMove.to.r * squareSize, squareSize, squareSize);
        // Draw a line connecting the centers.
        ctx.beginPath();
        ctx.moveTo(suggestedMove.from.c * squareSize + squareSize/2, suggestedMove.from.r * squareSize + squareSize/2);
        ctx.lineTo(suggestedMove.to.c * squareSize + squareSize/2, suggestedMove.to.r * squareSize + squareSize/2);
        ctx.stroke();
        ctx.setLineDash([]); // reset dashes
      }
    }

    // Deep copy the board.
    function copyBoard(b) {
      return b.map(row => row.slice());
    }

    // ----------------- Move Generation -----------------
    // Return allowed directions based on piece type.
    function getDirections(piece) {
      if (piece === 1) return [[-1, -1], [-1, 1]];  // CPU1 or Human piece: move upward
      if (piece === -1) return [[1, -1], [1, 1]];    // CPU2 piece: move downward
      return [[-1, -1], [-1, 1], [1, -1], [1, 1]];    // Kings move in all diagonals
    }

    // Get all valid moves for a given player.
    function getAllValidMoves(b, player) {
      let moves = [];
      let captureMoves = [];
      for(let r = 0; r < 8; r++){
        for(let c = 0; c < 8; c++){
          if(b[r][c] * player > 0) {
            let pieceMoves = getValidMovesForPiece(b, r, c);
            for(let m of pieceMoves) {
              if(m.captures && m.captures.length > 0) {
                captureMoves.push(m);
              } else {
                moves.push(m);
              }
            }
          }
        }
      }
      // If captures are available, they must be taken.
      return (captureMoves.length > 0) ? captureMoves : moves;
    }

    // Generate valid moves for a piece at (r, c).
    // Each move is an object: { from: {r, c}, to: {r, c}, captures: [{r, c}, ...], sequence: [...] }
    function getValidMovesForPiece(b, r, c) {
      let moves = [];
      let piece = b[r][c];
      let dirs = getDirections(piece);
      let captureSequences = [];
      function searchCaptures(boardState, row, col, captured, path) {
        let found = false;
        let directions = getDirections(boardState[row][col]);
        for(let d of directions) {
          let midR = row + d[0], midC = col + d[1];
          let landingR = row + 2 * d[0], landingC = col + 2 * d[1];
          if(landingR < 0 || landingR >= 8 || landingC < 0 || landingC >= 8) continue;
          if(boardState[midR][midC] * piece < 0 && boardState[landingR][landingC] === 0) {
            let newBoard = copyBoard(boardState);
            newBoard[row][col] = 0;
            newBoard[midR][midC] = 0;
            newBoard[landingR][landingC] = piece;
            if(piece === 1 && landingR === 0) newBoard[landingR][landingC] = 2;
            if(piece === -1 && landingR === 7) newBoard[landingR][landingC] = -2;
            searchCaptures(newBoard, landingR, landingC, captured.concat([{r: midR, c: midC}]), path.concat([{r: landingR, c: landingC}]));
            found = true;
          }
        }
        if(!found && captured.length > 0) {
          captureSequences.push({ from: {r, c}, to: path[path.length - 1], captures: captured, sequence: path });
        }
      }
      searchCaptures(b, r, c, [], []);
      if(captureSequences.length > 0) return captureSequences;
      // If no captures, look for simple moves.
      for(let d of dirs) {
        let newR = r + d[0], newC = c + d[1];
        if(newR >= 0 && newR < 8 && newC >= 0 && newC < 8 && b[newR][newC] === 0) {
          moves.push({ from: {r, c}, to: {r: newR, c: newC}, captures: [], sequence: [{r: newR, c: newC}] });
        }
      }
      return moves;
    }

    // Apply a move to the board.
    function applyMove(b, move) {
      let newBoard = copyBoard(b);
      let piece = newBoard[move.from.r][move.from.c];
      newBoard[move.from.r][move.from.c] = 0;
      for(let cap of move.captures) {
        newBoard[cap.r][cap.c] = 0;
      }
      newBoard[move.to.r][move.to.c] = piece;
      if(piece === 1 && move.to.r === 0) newBoard[move.to.r][move.to.c] = 2;
      if(piece === -1 && move.to.r === 7) newBoard[move.to.r][move.to.c] = -2;
      return newBoard;
    }

    // ----------------- Evaluation & Game Over Checks -----------------
    // Simple evaluation: weighted count of pieces.
    function evaluateBoard(b) {
      let score = 0;
      for(let r = 0; r < 8; r++){
        for(let c = 0; c < 8; c++){
          let piece = b[r][c];
          if(piece === 1) score += 1;
          else if(piece === 2) score += 1.5;
          else if(piece === -1) score -= 1;
          else if(piece === -2) score -= 1.5;
        }
      }
      return score;
    }

    // Check if a player has any pieces.
    function hasPieces(b, player) {
      for(let r = 0; r < 8; r++){
        for(let c = 0; c < 8; c++){
          if(b[r][c] * player > 0) return true;
        }
      }
      return false;
    }

    // Determine if the game is over.
    function gameOver(b, player) {
      let moves = getAllValidMoves(b, player);
      return (moves.length === 0 || !hasPieces(b, player));
    }

    // ----------------- Minimax AI -----------------
    // Minimax with alpha–beta pruning.
    function minimax(b, depth, alpha, beta, player) {
      if(depth === 0 || gameOver(b, player)) {
        return { score: evaluateBoard(b), move: null };
      }
      let moves = getAllValidMoves(b, player);
      if(moves.length === 0) {
        return { score: evaluateBoard(b), move: null };
      }
      let bestMove = null;
      if(player === 1) {  // CPU1 (or Human) is maximizer.
        let maxEval = -Infinity;
        for(let move of moves) {
          let newBoard = applyMove(b, move);
          let result = minimax(newBoard, depth - 1, alpha, beta, -player);
          if(result.score > maxEval) {
            maxEval = result.score;
            bestMove = move;
          }
          alpha = Math.max(alpha, result.score);
          if(beta <= alpha) break;
        }
        return { score: maxEval, move: bestMove };
      } else {  // CPU2 is minimizer.
        let minEval = Infinity;
        for(let move of moves) {
          let newBoard = applyMove(b, move);
          let result = minimax(newBoard, depth - 1, alpha, beta, -player);
          if(result.score < minEval) {
            minEval = result.score;
            bestMove = move;
          }
          beta = Math.min(beta, result.score);
          if(beta <= alpha) break;
        }
        return { score: minEval, move: bestMove };
      }
    }

    // ----------------- Game Loop & End Game Handling -----------------
    // End the game, display result and add a snapshot to history.
    function endGame(result) {
      gameActive = false;
      document.getElementById("winnerDisplay").textContent =
        "Game Over! " + (result === "Draw" ? "It's a draw." : "Winner: " + result);
      let snapshotURL = canvas.toDataURL();
      let gameHistory = document.getElementById("gameHistory");
      let gameDiv = document.createElement("div");
      gameDiv.innerHTML = "<strong>" + (result === "Draw" ? "Draw" : "Winner: " + result) + "</strong><br>" +
                          "<strong>Total Moves:</strong> " + moveCount;
      let img = document.createElement("img");
      img.src = snapshotURL;
      img.width = 100;
      img.height = 100;
      gameDiv.appendChild(img);
      gameHistory.appendChild(gameDiv);
      // After a short delay, auto-restart the game.
      setTimeout(restartGame, 1500);
    }

    // Main game loop. In Human vs CPU mode, if it's the human’s turn, wait for input.
    function gameLoop() {
      if(paused || !gameActive) return;
      if(moveCount >= MAX_MOVES || noCaptureCount >= MAX_NO_CAPTURE_MOVES) {
        endGame("Draw");
        return;
      }
      if(gameOver(board, currentPlayer)) {
        // If current player cannot move, the opponent wins (if they have pieces).
        let winner = hasPieces(board, -currentPlayer) ? (currentPlayer === 1 ? "CPU2" : "CPU1") : "Draw";
        endGame(winner);
        return;
      }
      // In Human vs CPU mode, if it's human's turn (player 1), wait for click/touch.
      if(gameMode === "human" && currentPlayer === 1) {
        setTimeout(gameLoop, 100);
        return;
      }
      // Otherwise, CPU makes a move.
      let { move } = minimax(board, maxDepth, -Infinity, Infinity, currentPlayer);
      if(move) {
        board = applyMove(board, move);
        drawBoard();
        moveCount++;
        if(move.captures.length === 0) {
          noCaptureCount++;
        } else {
          noCaptureCount = 0;
        }
      }
      currentPlayer = -currentPlayer;
      setTimeout(gameLoop, 500);
    }

    // ----------------- Human Input Handling -----------------
    // Handle mouse clicks.
    canvas.addEventListener("click", function(e) {
      if(gameMode !== "human" || !gameActive || currentPlayer !== 1) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / squareSize);
      const row = Math.floor(y / squareSize);
      
      handleSelection(row, col);
    });

    // Handle touch events for mobile devices.
    canvas.addEventListener("touchstart", function(e) {
      if(gameMode !== "human" || !gameActive || currentPlayer !== 1) return;
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      const col = Math.floor(x / squareSize);
      const row = Math.floor(y / squareSize);
      
      handleSelection(row, col);
    });

    // Common handler for piece selection.
    function handleSelection(row, col) {
      // If no piece selected, try to select a human piece.
      if(selectedPiece === null) {
        if(board[row][col] > 0) {
          selectedPiece = { r: row, c: col };
          drawBoard();
        }
      } else {
        // If clicking/touching the same piece, deselect.
        if(selectedPiece.r === row && selectedPiece.c === col) {
          selectedPiece = null;
          drawBoard();
          return;
        }
        // Check if a valid move exists for the selected piece.
        let validMoves = getValidMovesForPiece(board, selectedPiece.r, selectedPiece.c);
        let chosenMove = validMoves.find(m => m.to.r === row && m.to.c === col);
        if(chosenMove) {
          board = applyMove(board, chosenMove);
          moveCount++;
          if(chosenMove.captures.length === 0) {
            noCaptureCount++;
          } else {
            noCaptureCount = 0;
          }
          // Clear selection and suggestion after the move.
          selectedPiece = null;
          showSuggestion = false;
          suggestedMove = null;
          document.getElementById("suggestMoveBtn").textContent = "Show Suggestion";
          drawBoard();
          currentPlayer = -currentPlayer;
          setTimeout(gameLoop, 500);
        } else {
          // If the user touches another of their own pieces, update the selection.
          if(board[row][col] > 0) {
            selectedPiece = { r: row, c: col };
            drawBoard();
          }
        }
      }
    }

    // ----------------- Restart, Pause & Back Functions -----------------
    function restartGame() {
      board = initializeBoard();
      currentPlayer = 1;
      moveCount = 0;
      noCaptureCount = 0;
      gameActive = true;
      selectedPiece = null;
      showSuggestion = false;
      suggestedMove = null;
      document.getElementById("suggestMoveBtn").textContent = "Show Suggestion";
      document.getElementById("pauseBtn").textContent = "Pause";
      document.getElementById("winnerDisplay").textContent = "";
      drawBoard();
      setTimeout(gameLoop, 500);
    }

    document.getElementById("pauseBtn").addEventListener("click", () => {
      paused = !paused;
      document.getElementById("pauseBtn").textContent = paused ? "Resume" : "Pause";
      if(!paused && gameActive) {
        setTimeout(gameLoop, 500);
      }
    });

    document.getElementById("restartBtn").addEventListener("click", () => {
      restartGame();
    });

    // Suggest Move button functionality.
    document.getElementById("suggestMoveBtn").addEventListener("click", () => {
      // Only allow suggestion if in human mode and it's the human's turn.
      if(gameMode !== "human" || currentPlayer !== 1) return;
      if(!showSuggestion) {
        // Calculate suggestion using minimax.
        let result = minimax(board, maxDepth, -Infinity, Infinity, 1);
        if(result.move) {
          suggestedMove = result.move;
          showSuggestion = true;
          document.getElementById("suggestMoveBtn").textContent = "Hide Suggestion";
        }
      } else {
        // Toggle off suggestion.
        showSuggestion = false;
        suggestedMove = null;
        document.getElementById("suggestMoveBtn").textContent = "Show Suggestion";
      }
      drawBoard();
    });

    // Back to game type selection button functionality.
    document.getElementById("backBtn").addEventListener("click", () => {
      gameActive = false;
      // Hide game canvas and controls.
      canvas.style.display = "none";
      document.getElementById("controls").style.display = "none";
      // Show mode selection.
      document.getElementById("modeSelection").style.display = "block";
      // Clear any winner message.
      document.getElementById("winnerDisplay").textContent = "";
    });

    // ----------------- Mode Selection & Game Start -----------------
    document.getElementById("startGameBtn").addEventListener("click", () => {
      gameMode = document.getElementById("gameModeSelect").value;
      // Hide mode selection controls and show game canvas and buttons.
      document.getElementById("modeSelection").style.display = "none";
      canvas.style.display = "block";
      document.getElementById("controls").style.display = "block";
      restartGame();
    });
  </script>
</body>
</html>
